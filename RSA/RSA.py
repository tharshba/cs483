# Taegun Harshbarger
# RSA
import Functions

def mult_inv(a, n):
    t, newt = 0 ,1
    r, newr = n, a
    while newr != 0:
        q = r//newr
        t, newt = newt, t-q*newt
        r, newr = newr, r-q*newr
    if r > 1:
        raise Exception('not invertible')
    return t%n

# based on the theorm that gcd(a,b) = gcd(b,a%b)
def gcd(a,b):
    while b > 0:
        a,b = b, a % b
    return a

class RSA():
    def __init__(self, key_bit=None):
        if key_bit == None:
            self.key_bit = 2048
        else:
            self.key_bit = key_bit
        self.prime_bit = self.key_bit//2
        self.e = 65537


    def generate_keys(self):
        # generate public key n
        p = Functions.generatePrime(self.prime_bit)
        #print("p")
        #print(p)
        q = Functions.generatePrime(self.prime_bit)
        #print("q")
        #print(q)
        # generate primes while gcd(e, phi) != 1
        phi = (p-1)*(q-1)
        while gcd(phi, self.e) != 1:
            p = Functions.generatePrime(self.prime_bit)
            q = Functions.generatePrime(self.prime_bit)
            phi = (p-1)*(q-1)
        n = p*q
        #print("n")
        #print(n)
        # calculate private key: d
        phi = (p-1)*(q-1)
        #print("phi")
        #print(phi)
        d = mult_inv(self.e, phi)
        #print("d")
        #print(d)
        return n, d, self.e


    def encrypt(self, msg:bytes, e:int, n:int)->bytes:
        msg = int.from_bytes(msg, "big")
        cipher = Functions.modularExponentation(msg, e, n)
        return cipher.to_bytes((cipher.bit_length()+7)//8, 'big')


    def decrypt(self, msg:bytes, d:int, n:int)->bytes:
        msg = 22988164720332954970252350790833408545999965214180720385340078443263046111845113882769513399530982846123281994710980309123032340252981207429853482368071819354455184691240512480533368112451305035555004518758657621052051587529334614019960648790222690105111746958513937335587743718618960538392720918833874249851170986191353353356502176080454781132462019035638085135993675489226278167336283683167979194964698950342117661035871948639473193229881455591540986447096509801649761407127598025185785186622333405010811831832099670491933204618980306083549035997481784807420911736590301480517407289979441808855860946332828890866952
        plain = Functions.modularExponentation(msg, d, n)
        return plain.to_bytes((plain.bit_length()+7)//8, 'big')


msg = b'fucivorous'
rsa = RSA()
#n, d, e = rsa.generate_keys()
n=29008799743129408609374689940913917014975410601302875310985802492280495045922589888935712000566976207678361231023576202115045907373816208727599248741859896385032790108041743245706572427365886257356108623157972247650474325245330396098610404893097381495099032064033652644115515820179648479049624942642070340457014625132581812654221088247673884952542299230139429217012379354977878675418615576321419897628980337938455922580696428138686759821170269546826054049283587745366265729548822268707149247098989628592788023548515171813195269695361021786866589602732166513784399078184654229222640340774972521157076299039480956950693
d=7953661635172381148082057517864445654242537087367614728521352594470119405529441654550647862096037283912484138124458561969654697493020789090532537355119710669433361390533623516213763216920786886162502339892360091521299008961858826121060322650168101196048560464449405745794157556385066504723174856864601094765795919717131233770699363639262237622348522722074082587173058354923753341852477151233900771290898759897104049774818506013705430820128683172868280022924087414299138130881962991941694233218822176583978624220783911413665337104315294827319308875404030557555120657236911949472080307912595065914893661759406938684909
cipher = rsa.encrypt(msg, 65537, n)
print(int.from_bytes(cipher,'big'))
plain = rsa.decrypt(cipher, d, n)
print(plain)
